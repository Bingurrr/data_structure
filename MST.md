# MST

노드에 키값이 분기율 m-1만큼 들어있다
서브트리는 분기율인 m만큼 가지고 있다.

분기를 더 많아지게 하여 더 빨리 찾을 수 있다.
그 이유는 트리의 높이가 낮아지기 때문

### 다원 탐색 트리
이원 탐색 트리 보다 분기율을 높임
즉 m-1의 키값, m 개의 서브트리
트리의 높이를 감소시켰다 -> 삽입, 삭제 시간 감소

-> 삽입/삭제시 균형 유지의 어려움이 있다.

### MST 노드의 형식 
n : 한 노드 내의 키 값의 수 (1<= n <= m-1)
P : 서브트리에 대한 포인터 (0<= i <= n)
K : 키 값 (1<= i <= n)
A : 키 값으로 K를 가진 레코드에 대한 포인터 (1 <= i <= n)

### m-원 탐색 트리의 정의
1. 한 노드 내의 키 값들을 오름차순으로 정렬 
2. P가 지시하는 서브트리 내의 키 값 < Ki+1
3. Pn이 지시하는 서브트리 노드들의 키 값 > Kn
4. P가 가리키는 서브트리 는 위 성질을 만족하는 MST

### BST와의 비교
BST는 2-원 탐색트리 (m=2)ㄹ고 볼 수있다
AVL트리는 BST트리이다. 하지만 이 역은 성립하지 않는다.

### MST 검색
BST와 검색이 비슷하다
MST에서는 키값이 비교가 m-1번까지 이루어 질 수 있다.
가장 왼쪽 노드 -> k0 -> k0,k1사이의 서브트리 -> k1 ....

### MST 분석
노드의 최대 개수 : (m^h-1) / (m-1)
참고 -> 등비수열의 합

키의 최대 갯수 : 한 노드에 최대 (m-1) 개 크릴 저장하므로
{(m^h-1)/(m-1)} * (m-1) = m^h -1
ex) 4-원 탐색 트리의 높이가 3이면 최대 21개의 노드에 최대 63개키를 저장 할 수 있음.

N개의 키를 갖는 m-원 MST의 최소 높이 : m^h -1 -> logm(N+1)


# B-트리
- Balanced MST
-> Bayer 와 McCreigt가 고안

- 각 노드 마다 키 값이 최소 반 이상 찬 상태의 MST 트리
    루트를 제외한 모든 노드는 최소 [m/2]-1 c최대 m-1개의 키를 갖는다. 
    ex 분기가 10이면 최대 키는 9 -> 4개이상 키가 있어야함
    루트를 제외한 모든 내부 노드는 최소 [m/2]개 최대 m개의 소브트리를 갖는다
- 삽입, 삭제시 효율적인 군형 알고리즘을 제공


### B트리의 제약 조건
- [m/2]-1 <= 키의 개수 <= m-1
- [m/2] <= 서브트리의 개수 <= m

### 차수 m인 B-트리의 정의
1. B-트리는 공백이거나, 높이가 1이상인 m-원 탐색트리
2. 루트는 "0" 또는 "2에서 m개 사이"의 서브트리를 가짐
3. 루트를 제외한 모든 내부 노드는 최소 [m/2]개 최대 m개의 서브트리를 가짐
4. 루트를 제외한 모든 내부 노드에 있는 키의 개수는 그 노드의 서브트리 개수보다 하나 적음
5. 모든 단말노드는 같은 레벨이다.

### 트리 연산 검색
시간복잡도 최소 O(logmN) 최대 O(logm/2 N) -> 반밖에 다 채워져 있는경우

### 트리 연산 삽입
- 항상 단말 노드에서 삽입이 시작됨
- 단말 노드에서 overflow가 발생하면, 삽입이 단말에서 루트쪽으로 전파
  overflow가 일어나면 split가 발생한다.

### 트리 연산 삭제
삽입을 거꾸로 하는것
- 삭제할 키가 내부 노드에 있으면, 후행키와 교체
  따라서 삭제할 노드는 최종적으로 항상 단말 노드에 존재하게됨
- 항상 단말 노드에서 삭제됨
- findmin 오른쪽 트리에서 가장 낮은키 -> 후행키
- 키가 반까지로 줄어들면 underflow -> 형재 노드에서 키를 빌려온다.-> 부모노드로 올리고 부모노드를 내린다.

재분배의 경우
좌우 형제 노드중, 키 개수가 많은 쪽에서 키 차출함
좌우의 형제 노드의 키 개수가 같으면 왼쪽 형제 노드에서 키 차출함

노드 합병의 경우 왼쪽 노드와 합병을 함

MST는 단말노드의 크기가 내보노드의 크기의 합보다 훨씬 크다
모든 leaf는 디스크에 저장하여 성능 향상
모든 non-leaf는 메미로이 저장





